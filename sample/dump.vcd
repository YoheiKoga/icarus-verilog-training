$date
	Thu Jan  9 22:58:03 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module adder4bit_test $end
$var wire 4 ! s [3:0] $end
$var wire 1 " cout $end
$var reg 4 # a [3:0] $end
$var reg 4 $ b [3:0] $end
$var reg 1 % cin $end
$scope module dut $end
$var wire 4 & a [3:0] $end
$var wire 4 ' b [3:0] $end
$var wire 1 % cin $end
$var wire 4 ( s [3:0] $end
$var wire 1 " cout $end
$var wire 3 ) carry [2:0] $end
$scope module fa0 $end
$var wire 1 * a $end
$var wire 1 + b $end
$var wire 1 % cin $end
$var wire 1 , cout $end
$var wire 1 - net1 $end
$var wire 1 . net2 $end
$var wire 1 / net3 $end
$var wire 1 0 s $end
$upscope $end
$scope module fa1 $end
$var wire 1 1 a $end
$var wire 1 2 b $end
$var wire 1 3 cin $end
$var wire 1 4 cout $end
$var wire 1 5 net1 $end
$var wire 1 6 net2 $end
$var wire 1 7 net3 $end
$var wire 1 8 s $end
$upscope $end
$scope module fa2 $end
$var wire 1 9 a $end
$var wire 1 : b $end
$var wire 1 ; cin $end
$var wire 1 < cout $end
$var wire 1 = net1 $end
$var wire 1 > net2 $end
$var wire 1 ? net3 $end
$var wire 1 @ s $end
$upscope $end
$scope module fa3 $end
$var wire 1 A a $end
$var wire 1 B b $end
$var wire 1 C cin $end
$var wire 1 " cout $end
$var wire 1 D net1 $end
$var wire 1 E net2 $end
$var wire 1 F net3 $end
$var wire 1 G s $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
xG
xF
xE
xD
xC
xB
xA
x@
x?
x>
x=
x<
x;
x:
x9
x8
x7
x6
x5
x4
x3
x2
x1
x0
x/
x.
x-
x,
x+
x*
bx )
bx (
bx '
bx &
x%
bx $
bx #
x"
bx !
$end
#5
0@
0G
0;
0C
08
04
0<
0"
03
b0 !
b0 (
00
06
0>
0E
b0 )
0,
0-
0/
05
07
0=
0?
0D
0F
0.
0+
02
0:
0B
0*
01
09
0A
0%
b0 $
b0 '
b0 #
b0 &
#10
1@
1;
b101 !
b101 (
10
b10 )
14
1-
17
1+
12
11
b11 $
b11 '
b10 #
b10 &
#15
18
13
b11 )
1,
b110 !
b110 (
00
1.
1%
#20
