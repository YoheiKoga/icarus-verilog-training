$date
	Thu Jan  9 23:07:41 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module adder4bit_test $end
$var wire 4 ! s [3:0] $end
$var wire 1 " cout $end
$var reg 4 # a [3:0] $end
$var reg 4 $ b [3:0] $end
$var reg 1 % cin $end
$scope module dut $end
$var wire 4 & a [3:0] $end
$var wire 4 ' b [3:0] $end
$var wire 1 % cin $end
$var wire 4 ( s [3:0] $end
$var wire 1 " cout $end
$var wire 3 ) carry [2:0] $end
$scope module fa0 $end
$var wire 1 * a $end
$var wire 1 + b $end
$var wire 1 % cin $end
$var wire 1 , cout $end
$var wire 1 - net1 $end
$var wire 1 . net2 $end
$var wire 1 / net3 $end
$var wire 1 0 s $end
$upscope $end
$scope module fa1 $end
$var wire 1 1 a $end
$var wire 1 2 b $end
$var wire 1 3 cin $end
$var wire 1 4 cout $end
$var wire 1 5 net1 $end
$var wire 1 6 net2 $end
$var wire 1 7 net3 $end
$var wire 1 8 s $end
$upscope $end
$scope module fa2 $end
$var wire 1 9 a $end
$var wire 1 : b $end
$var wire 1 ; cin $end
$var wire 1 < cout $end
$var wire 1 = net1 $end
$var wire 1 > net2 $end
$var wire 1 ? net3 $end
$var wire 1 @ s $end
$upscope $end
$scope module fa3 $end
$var wire 1 A a $end
$var wire 1 B b $end
$var wire 1 C cin $end
$var wire 1 " cout $end
$var wire 1 D net1 $end
$var wire 1 E net2 $end
$var wire 1 F net3 $end
$var wire 1 G s $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
xG
xF
xE
xD
xC
xB
xA
x@
x?
x>
x=
x<
x;
x:
x9
x8
x7
x6
x5
x4
x3
x2
x1
x0
x/
x.
x-
x,
x+
x*
bx )
bx (
bx '
bx &
x%
bx $
bx #
x"
bx !
$end
#5
0@
0G
0;
0C
08
04
0<
0"
03
b0 !
b0 (
00
06
0>
0E
b0 )
0,
0-
0/
05
07
0=
0?
0D
0F
0.
0+
02
0:
0B
0*
01
09
0A
0%
b0 $
b0 '
b0 #
b0 &
#10
1@
1;
b101 !
b101 (
10
b10 )
14
1-
17
1+
12
11
b11 $
b11 '
b10 #
b10 &
#15
18
13
b11 )
1,
b110 !
b110 (
00
1.
1%
#20
1"
1E
1C
08
16
1<
1;
0@
1>
14
0G
13
1=
0-
1/
15
07
1D
b111 )
1,
1:
1*
01
1A
b0 !
b0 (
00
0.
b111 $
b111 '
b1001 #
b1001 &
0%
#25
1"
0G
1E
1C
1<
0@
1>
1;
14
08
16
13
1.
b111 )
1,
1-
0/
0+
02
0:
11
19
b0 !
b0 (
00
b0 $
b0 '
b1111 #
b1111 &
1%
#30
